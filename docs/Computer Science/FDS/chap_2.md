# Algorithm Analysis

- 算法定义：算法是在有限时间内解决特定问题的一组指令或操作步骤；
- 算法的特性：
   - 输入 (Input) ：算法具有零个或多个输入；
   - 输出 (Output) ：算法至少有一个或多个输出；
   - 明确性 (Definiteness) ：算法的每一步骤都必须明确且无歧义；
   - 有限性 (Finiteness) ：算法必须在有限步骤内结束；
   - 有效性 (Effectiveness) ：算法的每一步骤都必须是可行的，即能够通过已经定义的操作来实现；

??? note "注"

    一个用程序设计语言写的程序不一定需要满足有限性。

## 算法分析

时间与空间复杂度与机器及编译器无关，分析的是随着数据量变大时的增长趋势。

### 渐进时间复杂度
#### 定义

- 函数渐进上界：$T (N) = O(f(N))$，表示存在正常数 $c$ 和 $n_0$，使得对所有 $N \geq n_0$，有 $T(N) \leq c \cdot f(N)$，为最差时间复杂度；

我们也给出常见的时间复杂度类型（按照从低到高顺序排列）

$$
O(1) < O(\log N) < O(N) < O(N \log N) < O(N^2) < O(N^3) < O(2^N) < O(N!)
$$

- 函数渐进下界：$T (N) = \Omega(f(N))$，表示存在正常数 $c$ 和 $n_0$，使得对所有 $N \geq n_0$，有 $c \cdot f(N) \leq T(N)$，为最佳时间复杂度；
- 平均时间复杂度：$T (N) = \Theta(f(N))$，表示同时满足 $T(N) = O(f(N))$ 和 $T(N) = \Omega(f(N))$，为平均时间复杂度；
- 小 $o$ 符号：$T (N) = o(f(N))$，表示$T(N) = O(f(N))$，并且$T (N) \neq \Omega(f(N))$；

#### 规则

- 如果 $T_1(N) = O(f(N))$，$T_2(N) = O(g(N))$，则：
    - $T_1(N) + T_2(N) = \max ( O(f(N)), O(g(N)) )$；
    - $T_1(N) \cdot T_2(N) = O(f(N) \cdot g(N))$；
- 条件语句：不会超过测试条件与两者运行时间的最长者的和；